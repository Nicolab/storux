{"version":3,"sources":["../node_modules/evemit/evemit.js","utils.js","Scope.js","Store.js","index.js"],"names":["Store","utils","clone","target","sources","forEach","source","descriptors","Object","keys","reduce","_descriptors","key","getOwnPropertyDescriptor","getOwnPropertySymbols","sym","descriptor","enumerable","defineProperties","isEquival","a","b","aProps","getOwnPropertyNames","bProps","aPropsLn","length","i","propName","ucFirst","str","charAt","toUpperCase","substr","lcFirst","toLowerCase","generateStoreName","store","displayName","getFuncName","constructor","getActionId","action","id","toId","v","fn","fnName","name","exec","toString","defineDisplayName","obj","defineProperty","configurable","writable","value","isStore","require","getProtoProps","endProto","props","__proto__","concat","prototype","filter","prop","indexOf","module","exports","Evemit","defaultDispatcher","ReferenceError","Scope","opt","storux","initialState","dispatch","_lc","on","bind","once","off","emit","listeners","_p","aq","ca","cl","state","listener","TypeError","push","unlisten","splice","nextState","ln","replaceState","hasChanged","payload","_action","hooks","resolve","fnResult","scope","_inProgress","Error","_reduceActionHooks","setState","actionId","actionName","result","_next","shift","actionArgs","Promise","proceed","ok","setImmediate","_dispatcher","slice","apply","getState","hook","_nextState","_getHandlerArgs","_createActionProxy","undefined","defer","args","actions","mountAction","_generateActions","arguments","method","save","default","dpsp","s","o","p","c","_mount","h","k","m","type","Storux","stores","StoruxStore","storeName","removeScopePropsAfterCreation","thisScope"],"mappings":"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","file":"storux.js","sourceRoot":"../src","sourcesContent":["/**\n * @name Evemit\n * @description Minimal and fast JavaScript event emitter for Node.js and front-end.\n * @author Nicolas Tallefourtane <dev@nicolab.net>\n * @link https://github.com/Nicolab/evemit\n * @license MIT https://github.com/Nicolab/evemit/blob/master/LICENSE\n */\n;(function() {\n\n  'use strict';\n\n  /**\n   * Evemit\n   *\n   * @constructor\n   * @api public\n   */\n  function Evemit() {\n    this.events = {};\n  }\n\n  /**\n   * Register a new event listener for a given event.\n   *\n   * @param {string}   event      Event name.\n   * @param {function} fn         Callback function (listener).\n   * @param {*}        [context]  Context for function execution.\n   * @return {Evemit} Current instance.\n   * @api public\n   */\n  Evemit.prototype.on = function(event, fn, context) {\n\n    if (!this.events[event]) {\n      this.events[event] = [];\n    }\n\n    if(context) {\n      fn._E_ctx = context;\n    }\n\n    this.events[event].push(fn);\n\n    return this;\n  };\n\n  /**\n   * Add an event listener that's only called once.\n   *\n   * @param {string}    event      Event name.\n   * @param {function}  fn         Callback function (listener).\n   * @param {*}         [context]  Context for function execution.\n   * @return {Evemit} Current instance.\n   * @api public\n   */\n  Evemit.prototype.once = function(event, fn, context) {\n    fn._E_once = true;\n    return this.on(event, fn, context);\n  };\n\n  /**\n   * Emit an event to all registered event listeners.\n   *\n   * @param  {string} event      Event name.\n   * @param  {*}      [...arg]   One or more arguments to pass to the listeners.\n   * @return {bool} Indication, `true` if at least one listener was executed,\n   * otherwise returns `false`.\n   * @api public\n   */\n  Evemit.prototype.emit = function(event, arg1, arg2, arg3, arg4) {\n\n    var fn, evs, args, aLn;\n\n    if(!this.events[event]) {\n      return false;\n    }\n\n    args = Array.prototype.slice.call(arguments, 1);\n    aLn  = args.length;\n    evs  = this.events[event];\n\n    for(var i = 0, ln = evs.length; i < ln; i++) {\n\n      fn = evs[i];\n\n      if (fn._E_once) {\n        this.off(event, fn);\n      }\n\n      // Function.apply() is a bit slower, so try to do without\n      switch (aLn) {\n        case 0:\n          fn.call(fn._E_ctx);\n          break;\n        case 1:\n          fn.call(fn._E_ctx, arg1);\n          break;\n        case 2:\n          fn.call(fn._E_ctx, arg1, arg2);\n          break;\n        case 3:\n          fn.call(fn._E_ctx, arg1, arg2, arg3);\n          break;\n        case 4:\n          fn.call(fn._E_ctx, arg1, arg2, arg3, arg4);\n          break;\n        default:\n          fn.apply(fn._E_ctx, args);\n      }\n    }\n\n    return true;\n  };\n\n  /**\n   * Remove event listeners.\n   *\n   * @param {string}   event  The event to remove.\n   * @param {function} fn     The listener that we need to find.\n   * @return {Evemit} Current instance.\n   * @api public\n   */\n  Evemit.prototype.off = function(event, fn) {\n\n    if (!this.events[event]) {\n      return this;\n    }\n\n    for (var i = 0, ln = this.events[event].length; i < ln; i++) {\n\n      if (this.events[event][i] === fn) {\n\n        this.events[event][i] = null;\n        delete this.events[event][i];\n      }\n    }\n\n    // re-index\n    this.events[event] = this.events[event].filter(function(ltns) {\n      return typeof ltns !== 'undefined';\n    });\n\n    return this;\n  };\n\n  /**\n   * Get a list of assigned event listeners.\n   *\n   * @param {string} [event] The events that should be listed.\n   * If not provided, all listeners are returned.\n   * Use the property `Evemit.events` if you want to get an object like\n   * ```\n   * {event1: [array of listeners], event2: [array of listeners], ...}\n   * ```\n   *\n   * @return {array}\n   * @api public\n   */\n  Evemit.prototype.listeners = function(event) {\n    var evs, ltns;\n\n    if(event) {\n      return this.events[event] || [];\n    }\n\n    evs  = this.events;\n    ltns = [];\n\n    for(var ev in evs) {\n      ltns = ltns.concat(evs[ev].valueOf());\n    }\n\n    return ltns;\n  };\n\n  /**\n   * Expose Evemit\n   * @type {Evemit}\n   */\n  if(typeof module !== 'undefined' && module.exports) {\n    module.exports = Evemit;\n  } else {\n    window.Evemit = Evemit;\n  }\n\n})();\n","/**\n * This file is part of storux.\n *\n * (c) Nicolas Tallefourtane <dev@nicolab.net>\n *\n * For the full copyright and license information, please view the LICENSE file\n * distributed with this source code\n * or visit https://github.com/Nicolab/storux\n */\n\nlet Store;\n\nlet utils = {\n  clone(target, ...sources) {\n    sources.forEach((source) => {\n      let descriptors = Object.keys(source).reduce(function(_descriptors, key) {\n        _descriptors[key] = Object.getOwnPropertyDescriptor(source, key);\n        return _descriptors;\n      }, {});\n\n      // By default, Object.assign copy the enumerable symbols\n      Object.getOwnPropertySymbols(source).forEach(function(sym) {\n        let descriptor = Object.getOwnPropertyDescriptor(source, sym);\n\n        if (descriptor.enumerable) {\n          descriptors[sym] = descriptor;\n        }\n      });\n\n      Object.defineProperties(target, descriptors);\n    });\n\n    return target;\n  },\n\n  isEquival(a, b) {\n    // Create arrays of property names\n    let aProps = Object.getOwnPropertyNames(a);\n    let bProps = Object.getOwnPropertyNames(b);\n    let aPropsLn = aProps.length;\n    let bPropsLn = bProps.length;\n\n    // If number of properties is different,\n    // objects are not equivalent\n    if (aPropsLn !== bPropsLn) {\n      return false;\n    }\n\n    for (let i = 0; i < aPropsLn; i++) {\n      let propName = aProps[i];\n\n      // If values of same property are not equal,\n      // objects are not equivalent\n      if (a[propName] !== b[propName]) {\n        return false;\n      }\n    }\n\n    // If we made it this far, objects\n    // are considered equivalent\n    return true;\n  },\n\n  /**\n   * Capitalizes the first letter.\n   * @param {string} str\n   * @return {string}\n   */\n  ucFirst(str) {\n    return str.charAt(0).toUpperCase() + str.substr(1);\n  },\n\n  /**\n   * Lowercase the first letter.\n   * @param {string} str\n   * @return {string}\n   */\n  lcFirst(str) {\n    return str.charAt(0).toLowerCase() + str.substr(1);\n  },\n\n  // handlerNameToActionName(str) {\n  //   return utils.lcFirst(str.substring(2));\n  // },\n\n  /**\n   * Generate a conventional store name.\n   *\n   * @param  {Store}  store\n   * @return {string}\n   */\n  generateStoreName(store) {\n    return utils.lcFirst(store.displayName || utils.getFuncName(store.constructor));\n  },\n\n  getActionId(store, action) {\n    if (typeof action === 'string') {\n      return store.displayName + '.' + action;\n    }\n\n    return action.id;\n  },\n\n  toId(v) {\n    return typeof v === 'string' ? v : v.id;\n  },\n\n  getFuncName(fn) {\n    let fnName = fn.displayName || fn.name;\n\n    if (fnName) {\n      return fnName;\n    }\n\n    fnName = /^function\\s+([\\w$]+)\\s*\\(/.exec(fn.toString());\n\n    return fnName ? fnName[1] : null;\n  },\n\n  defineDisplayName(obj, displayName) {\n    Object.defineProperty(obj, 'displayName', {\n      enumerable: true,\n      configurable: false,\n      writable: false,\n      value: displayName,\n    });\n  },\n\n  isStore(value) {\n    // avoid circular dependencies\n    if (!Store) {\n      Store = require('./Store');\n    }\n\n    return value instanceof Store === true;\n  },\n\n  /**\n   * Get all the properties of the prototype of `obj` and its parents.\n   *\n   * @param  {object} obj\n   * @param  {object} endProto=Object Object that interrupts the proto escalation.\n   * @param  {array}  props=[] Initial properties.\n   * @return {array} Properties list.\n   */\n  getProtoProps(obj, endProto = Object, props = []) {\n    if (obj === endProto) {\n      return props;\n    }\n\n    return utils.getProtoProps(\n      obj.__proto__,\n      endProto,\n      props.concat(Object\n        .getOwnPropertyNames(obj.prototype)\n        .filter(function(prop) {\n          return props.indexOf(prop) === -1;\n        })\n      )\n    );\n  },\n\n  // /**\n  //  * @param  {Store}  store Store class or Store instance.\n  //  * @return {array}\n  //  */\n  // getStoreProtoProps(store) {\n  //   return utils.getProtoProps(\n  //     utils.isStore(store) ? store.constructor : store,\n  //     Store\n  //   );\n  // }\n};\n\nmodule.exports = utils;\n","/**\n * This file is part of storux.\n *\n * (c) Nicolas Tallefourtane <dev@nicolab.net>\n *\n * For the full copyright and license information, please view the LICENSE file\n * distributed with this source code\n * or visit https://github.com/Nicolab/storux\n */\n\nlet Evemit = require('evemit');\n\nlet {\n  clone,\n  isEquival,\n  getFuncName,\n  defineDisplayName,\n  generateStoreName,\n} = require('./utils');\n\nfunction defaultDispatcher() {\n  throw new ReferenceError('No action in progress');\n}\n\n/**\n * Handle the scope of a `Store` instance.\n */\nclass Scope {\n  /**\n   * @constructor\n   * @param  {object}  cfg             Scope config.\n   * @param  {Store}   cfg.store       The `Store` instance handled\n   * by the `Scope` instance.\n   * @param  {object}  cfg.opt         Store options\n   * @param  {Storux}  cfg.opt.storux  A `Storux` instance.\n   */\n  constructor({store, opt}) {\n    this.storux = opt.storux;\n    opt.storux = null;\n\n    this.opt = opt;\n    this.store = store;\n    this.initialState = this.opt.initialState\n      ? clone({}, this.opt.initialState)\n      : {}\n    ;\n\n    this.clone = clone;\n    this.dispatch = defaultDispatcher;\n\n    // lifecycle\n    this._lc = new Evemit();\n    this.on = this._lc.on.bind(this._lc);\n    this.once = this._lc.once.bind(this._lc);\n    this.off = this._lc.off.bind(this._lc);\n    this.emit = this._lc.emit.bind(this._lc);\n    this.listeners = this._lc.listeners.bind(this._lc);\n\n    // store name\n    defineDisplayName(this, generateStoreName(this.store));\n\n    // Internal object.\n    // Be careful, the reliability of the store can be degraded if misused.\n    // Risk of headache with the object reference,\n    // breaking the state flow in the application.\n    // But the perfs are better than a private Map.\n    this._p = {\n      // Queue (actions stack)\n      aq: [],\n\n      // current action\n      ca: null,\n\n      // change listeners\n      cl: [],\n    };\n\n    // force the pattern: constructor -> init -> state usable\n    // avoid to update the state in the constructor before the initialization\n    this.on('init', () => {\n      this.dispatch = defaultDispatcher;\n      this._p.ca = null;\n      this._p.state = clone({}, this.initialState);\n    });\n  }\n\n  /**\n   * Attach a global state change `listener`.\n   *\n   * @param  {function} listener A callback called after each change.\n   * The callback receives the current `Store` instance.\n   * @return {function} A function to detach the listener.\n   * @see Scope.unlisten()\n   */\n  listen(listener) {\n    if (typeof listener !== 'function') {\n      throw new TypeError(this.displayName + ': listener must be a function.');\n    }\n\n    this._p.cl.push(listener);\n    this.emit('listen', listener);\n\n    // push proxy\n    return () => this.unlisten(listener);\n  }\n\n  /**\n   * Detach a global state change `listener`.\n   *\n   * @param  {function} listener  A callback attached with `store.scope.listen()`.\n   * @return {bool}     `true` if the `listener` was found and detached,\n   * `false` otherwise.\n   * @see Scope.listen()\n   */\n  unlisten(listener) {\n    let listeners = this._p.cl;\n    let i = listeners.indexOf(listener);\n\n    if (i === -1) {\n      return false;\n    }\n\n    listeners.splice(i, 1);\n    this.emit('unlisten', listener);\n\n    return true;\n  }\n\n  /**\n   * Get a clone of the state.\n   *\n   * @return {object} A clone of the state.\n   */\n  getState() {\n    return clone({}, this._p.state);\n  }\n\n  /**\n   * Like `setState()` but replace all state by `nextState`.\n   *\n   * @param  {object} [nextState={}] Next state.\n   * @return {bool} `true` if the state was changed,\n   * `false` if the state is unchanged.\n   */\n  replaceState(nextState = {}) {\n    let ln, listeners;\n\n    if (isEquival(this._p.state, nextState)) {\n      return false;\n    }\n\n    this._p.state = clone({}, nextState);\n    ln = this._p.cl.length;\n\n    if (ln) {\n      listeners = this._p.cl;\n\n      for (let i = 0; i < ln; i++) {\n        if (typeof listeners[i] === 'function') {\n          listeners[i](this.store);\n        } else {\n          // prevent memory leak\n          listeners.splice(i, 1);\n        }\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * Performs a shallow merge of `obj` into current state of the store.\n   *\n   * @param  {object} obj Object to merge with the existing state.\n   * @return {bool} `true` if the state was changed,\n   * `false` if the state is unchanged.\n   */\n  setState(obj) {\n    return this.replaceState({...this._p.state, ...obj});\n  }\n\n  /**\n   * Reset the state to the initial state.\n   *\n   * @return {bool} `true` if the state was changed,\n   * `false` if the state is unchanged.\n   */\n  resetState() {\n    let hasChanged = this.replaceState(this.initialState);\n\n    if (hasChanged) {\n      this.emit('resetState');\n    }\n\n    return hasChanged;\n  }\n\n  /**\n   * Recycle the store:\n   *  * Reset the state to the initial state.\n   *  * Emit `init` event, with one argument `hasChanged`.\n   *\n   * ```js\n   * myStore.scope.on('init', function(hasChanged) {\n   *   // if first \"init\"\n   *   if (typeof hasChanged === 'undefined') {\n   *     console.log('first init');\n   *     return;\n   *   }\n   *\n   *   // recycled\n   *   console.log('recycled, state changed? ', hasChanged);\n   * });\n   *\n   * myStore.scope.recycle();\n   * ```\n   *\n   * @return {bool} `true` if the state was changed,\n   * `false` if the state is unchanged.\n   */\n  recycle() {\n    let hasChanged = this.replaceState(this.initialState);\n\n    this.emit('init', hasChanged);\n\n    return hasChanged;\n  }\n\n  // eslint-disable-next-line spaced-comment\n  /*-----------------------------------------------------------------------*\\\n    Actions\n  \\*-----------------------------------------------------------------------*/\n\n  /**\n   * Dispatch the payload.\n   * Use this method when the state does not need to be updated.\n   *\n   * @param {*} [payload] Payload to dispatch.\n   * @param {object} [obj] Object to merge with the existing state.\n   * @return {Promise.<bool>}  A promise that will be resolved with a `boolean`.\n   * `true` if the state was changed, `false` if the state is unchanged.\n   */\n  // dispatch = defaultDispatcher\n\n  /**\n   * Save the object with the existing state and dispatch the payload.\n   *\n   * @param {object} obj Object to merge with the existing state.\n   * Use only when the action has no action hook(s) defined.\n   * @param {*} payload Payload to dispatch.\n   * @return {Promise.<bool>}  A promise that will be resolved with a `boolean`.\n   * `true` if the state was changed, `false` if the state is unchanged.\n   */\n  save(obj, payload) {\n    if (!this.dispatch._action || !this._p.ca) {\n      throw new ReferenceError('No action in progress.');\n    }\n\n    if (this.dispatch._action.hooks.length) {\n      throw new TypeError(\n        'This action have one or more hooks. Use dispatch() instead save().'\n      );\n    }\n\n    if (typeof obj !== 'object') {\n      throw new TypeError(\n        'save() require an object in ' + this.dispatch._action.id\n      );\n    }\n\n    return this.dispatch(payload, obj);\n  }\n\n  /**\n   * Dispatch an `action`.\n   * If one or more hooks exists, they are called one by one (reducing).\n   *\n   * @param  {function} action  Action.\n   * @param  {object}  [payload]  payload dispatched from the action.\n   * @param {object} [obj] Object to merge with the existing state,\n   * used only when the action has no hooks defined.\n   * @return {bool}  `true` if the state was changed,\n   * `false` if the state is unchanged.\n   */\n  _dispatcher({resolve, action, payload, obj, fnResult}) {\n    let hasChanged;\n    const scope = this;\n\n    if (scope.dispatch._inProgress) {\n      throw new Error('Dispatching in progress: ' + action.id\n        + ' The dispatcher must be called only once by action.'\n      );\n    }\n\n    scope.dispatch._inProgress = true;\n\n    // if no action hooks\n    if (!action.hooks.length) {\n      hasChanged = obj ? this.setState(obj) : false;\n    } else {\n      // call one by one (reducing).\n      hasChanged = this._reduceActionHooks(action, payload);\n    }\n\n    // reset the dispatcher\n    scope.dispatch = defaultDispatcher;\n\n    resolve(fnResult);\n\n    scope.storux.emit(\n      'after.' + action.id,\n      payload,\n      fnResult,\n      hasChanged\n    );\n\n    scope.storux.emit('after', {\n      actionId: action.id,\n      actionName: action.displayName,\n      result: fnResult,\n      payload,\n      hasChanged,\n    });\n\n    // reset current action\n    scope._p.ca = null;\n    scope._next();\n\n    return hasChanged;\n  }\n\n  _next() {\n    if (this._p.aq.length && !this.dispatch._action && !this._p.ca) {\n      this._p.aq.shift()();\n      return true;\n    }\n\n    return false;\n  }\n\n  _createActionProxy(fn) {\n    const action = (...actionArgs) => {\n      return new Promise((resolve) => {\n        const scope = this;\n\n        this._p.aq.push(\n          /**\n           * Call the original action.\n           * `this` of implemented action method bind to the `Store` instance.\n           *\n           * @return {*} The original return value.\n           */\n          function proceed() {\n            if (scope.dispatch._action || scope._p.ca) {\n              throw new Error(\n                action.id + ' can be called, because the action '\n                + scope.dispatch._action.id + ' is not finished'\n              );\n            }\n\n            /**\n            * Dispatch the payload. Added when the action is called.\n            *\n            * @param {*} payload\n            * @param {object} [obj] Object to merge with the existing state,\n            * used only when the action has no action handler(s) defined.\n            * @return {Promise.<bool>}  A promise that will be resolved with a `boolean`.\n            * `true` if the state was changed, `false` if the state is unchanged.\n            */\n            scope.dispatch = function dispatch(payload, obj) {\n              // eslint-disable-next-line promise/param-names\n              return new Promise(function(ok) {\n                // dispatch on the next event loop\n                setImmediate(function() {\n                  ok(scope._dispatcher(\n                    {resolve, action, payload, obj, fnResult}\n                  ));\n                });\n              });\n            };\n\n            // add the current action ref when the action is called\n            scope.dispatch._action = action;\n            scope._p.ca = action.id;\n\n            // lifecycle\n\n            // shallow copy\n            actionArgs = actionArgs.slice();\n\n            scope.storux.emit('before.' + action.id, actionArgs);\n\n            scope.storux.emit('before', {\n              actionId: action.id,\n              actionName: action.displayName,\n              actionArgs,\n            });\n\n            const fnResult = fn.apply(scope.store, actionArgs);\n          }\n        );\n\n        // if only one in the stack, start the call stack.\n        // if not, the dispatcher will manage the progress of the stack.\n        if (this._p.aq.length === 1) {\n          this._next();\n        }\n      });\n    };\n\n    return action;\n  }\n\n  _getHandlerArgs({action, payload, nextState}) {\n    return [\n      nextState,\n      payload,\n      {\n        actionId: action.id,\n        actionName: action.displayName,\n      },\n    ];\n  }\n\n  _reduceActionHooks(action, payload) {\n    let nextState = this.getState();\n\n    for (let i = 0, ln = action.hooks.length; i < ln; i++) {\n      let hook = action.hooks[i];\n\n      if (typeof hook !== 'function') {\n        throw new TypeError(\n          'The hook must be a function. Hook type: ' + typeof hook\n        );\n      }\n\n      let _nextState = hook.apply(\n        this.store,\n        this._getHandlerArgs({action, payload, nextState})\n      );\n\n      // if it break the chain, it's a design error\n      if (!_nextState || typeof _nextState !== 'object') {\n        throw new TypeError(\n          'The hook \"' + getFuncName(hook)\n          + '\" should return the next state for the action ' + action.id\n        );\n      }\n\n      nextState = _nextState;\n    }\n\n    return this.replaceState(nextState);\n  }\n\n  /**\n   * Mount an action.\n   *\n   * @param  {string} actionName Action name (method name).\n   * @return {Scope} Current instance.\n   */\n  mountAction(actionName, fn) {\n    // if already mounted\n    if (this.store[actionName] && this.store[actionName].id) {\n      return this;\n    }\n\n    const action = this._createActionProxy(fn);\n\n    // this.store[actionName].displayName\n    defineDisplayName(action, actionName);\n\n    let fnName = getFuncName(fn);\n\n    if (fnName && typeof this.store[fnName] === 'function') {\n      this.store[fnName] = undefined;\n    }\n\n    action.id = this.displayName + '.' + action.displayName;\n    action.defer = (...args) => setImmediate(action.apply(this.store, args));\n    action.hooks = [];\n\n    // mounted!\n    this.store[actionName] = action;\n\n    return this;\n  }\n\n  /**\n   * Mount the actions of the store.\n   *\n   * ```js\n   * this.scope.mountActions({\n   *  create: this.create,\n   *  update: this.update,\n   * });\n   * ```\n   *\n   * @param  {object} actions One or more actions names.\n   * @return {Store}  Current instance.\n   */\n  mountActions(actions) {\n    if (typeof actions !== 'object') {\n      throw new ReferenceError(\n        'mountActions() requiere one or more actions to mount'\n      );\n    }\n\n    for (let name in actions) {\n      this.mountAction(name, actions[name]);\n    }\n\n    return this;\n  }\n\n  /**\n   * Generate one or more actions if they have not been defined.\n   * The difference with this `ensureSaveActions()`,\n   * the payload is not saved in the state.\n   * The generated actions use `Scope.dispatch()`.\n   *\n   * @param  {string} ...actionName One or more actions names.\n   * @return {Store}  Current instance.\n   */\n  ensureActions(/* actionName, ...*/) {\n    return this._generateActions('dispatch', arguments);\n  }\n\n  /**\n   * Generate one or more actions if they have not been defined.\n   * The difference with `ensureActions()`,\n   * the payload is saved in the state.\n   * The generated actions use `Scope.save()`.\n   *\n   * @param  {string} ...actionName One or more actions names.\n   * @return {Store}  Current instance.\n   */\n  ensureSaveActions(/* actionName, ...*/) {\n    return this._generateActions('save', arguments);\n  }\n\n  _generateActions(method, actions) {\n    let store = this.store;\n\n    for (let i = 0, ln = actions.length; i < ln; i++) {\n      let actionName = actions[i];\n\n      if (store[actionName]) {\n        continue;\n      }\n\n      // create the action method (passthrough)\n      store[actionName] = function(payload) {\n        if (method === 'save') {\n          store.scope.save(payload, payload);\n        } else {\n          store.scope.dispatch(payload);\n        }\n\n        return payload;\n      };\n\n      this.mountAction(actionName, store[actionName]);\n    }\n\n    return this;\n  }\n}\n\nmodule.exports = Scope;\nmodule.exports.default = Scope;\n","/**\n * This file is part of storux.\n *\n * (c) Nicolas Tallefourtane <dev@nicolab.net>\n *\n * For the full copyright and license information, please view the LICENSE file\n * distributed with this source code\n * or visit https://github.com/Nicolab/storux\n */\n\nconst Scope = require('./Scope');\n\n// scope shortcut, define protected property in the store\nconst dpsp = function(s, o, p, c) {\n  Object.defineProperty(o, c || p, {\n    enumerable: false,\n    configurable: false,\n    writable: false,\n    value: s[p].bind(s),\n  });\n};\n\n/**\n * Base class for each store.\n */\nclass Store {\n  constructor(opt = {}) {\n    let scope = new Store.Scope({\n      store: this,\n      opt,\n    });\n\n    Object.defineProperty(this, 'scope', {\n      enumerable: true,\n      configurable: false,\n      writable: false,\n      value: scope,\n    });\n\n    dpsp(scope, this, 'getState');\n    dpsp(scope, this, 'setState');\n    dpsp(scope, this, 'replaceState');\n    this._mount();\n  }\n\n  _dispatch(payload, obj) {\n    return this.scope.dispatch(payload, obj);\n  }\n\n  _save(obj, payload) {\n    return this.scope.save(obj, payload);\n  }\n\n  /**\n   * Called in the constructor to mount the decorators.\n   * After construction, this method is undefined.\n   */\n  _mount() {\n    // hooks\n    let h = [];\n\n    for (let k in this._mount) {\n      let m = this._mount[k];\n\n      if (m.type === 'action') {\n        this.scope.mountAction(m.name, m.fn);\n        continue;\n      }\n\n      if (m.type === 'hook') {\n        h.push(m);\n      }\n    }\n\n    // mount the hooks after all actions are mounted\n    for (let i = 0, ln = h.length; i < ln; i++) {\n      this[h[i].actionName].hooks.push(this[h[i].key]);\n    }\n\n    // disable this method\n    // NOTE: delete instance property has not effect,\n    // because it use the parent\n    this._mount = undefined;\n  }\n}\n\nStore.Scope = Scope;\n\nmodule.exports = Store;\nmodule.exports.default = Store;\n","/**\n * This file is part of storux.\n *\n * (c) Nicolas Tallefourtane <dev@nicolab.net>\n *\n * For the full copyright and license information, please view the LICENSE file\n * distributed with this source code\n * or visit https://github.com/Nicolab/storux\n */\n\nlet Evemit = require('evemit');\nlet Store = require('./Store');\nlet Scope = require('./Scope');\n\nlet {\n  isStore,\n  toId,\n} = require('./utils');\n\nclass Storux {\n  /**\n   * @constructor\n   */\n  constructor() {\n    this.stores = {};\n    this.Store = Storux.Store;\n\n    // lifecycle\n    this._lc = new Evemit();\n    this.on = this._lc.on.bind(this._lc);\n    this.once = this._lc.once.bind(this._lc);\n    this.off = this._lc.off.bind(this._lc);\n    this.emit = this._lc.emit.bind(this._lc);\n    this.listeners = this._lc.listeners.bind(this._lc);\n  }\n\n  /**\n   * Create a new `Store` instance.\n   *\n   * @param {Store}    StoruxStore A class (will be instancied) inherited from `Store`.\n   * @param {object}   opt Options.\n   * @param {object}   [opt.storeOpt] Specific store options (user land).\n   * @param {object}   [opt.initialState] Initial state.\n   * @return {Store} The new `Store` instance.\n   */\n  create(StoruxStore, opt = {}) {\n    let storeName, store;\n\n    opt.storux = this;\n    store = new StoruxStore(opt);\n\n    if (!isStore(store)) {\n      throw new TypeError(\n        'Storux.create() - `store` argument must be an instance of `Store`'\n      );\n    }\n\n    storeName = store.scope.displayName;\n\n    if (this.stores[storeName]) {\n      throw new Error(\n        'The store `' + storeName + '` is already defined'\n        + ' in the `Storux` instance.'\n      );\n    }\n\n    Object.defineProperty(this.stores, storeName, {\n      enumerable: true,\n      configurable: false,\n      writable: false,\n      value: store,\n    });\n\n    this.emit('create', this.stores[storeName]);\n    this.emit('create.' + storeName, this.stores[storeName]);\n\n    // Remove the properties (of scope) used only to create the store\n    // NOTE: `delete` is not appropriate because the value of the prototype\n    // will be used instead. We do not want to delete at the prototype level\n    // otherwise it would be reflected in all stores.\n    Storux.removeScopePropsAfterCreation.forEach(function(prop) {\n      store.scope[prop] = undefined;\n    });\n\n    // Now, this store is initialized\n    store.scope.emit('init');\n\n    return this.stores[storeName];\n  }\n\n  before(action, listener, thisScope) {\n    this.on('before.' + toId(action), listener, thisScope);\n    return this;\n  }\n\n  offBefore(action, listener) {\n    this.off('before.' + toId(action), listener);\n    return this;\n  }\n\n  after(action, listener, thisScope) {\n    this.on('after.' + toId(action), listener, thisScope);\n    return this;\n  }\n\n  offAfter(action, listener) {\n    this.off('after.' + toId(action), listener);\n    return this;\n  }\n\n  beforeEach(listener, thisScope) {\n    this.on('before', listener, thisScope);\n    return this;\n  }\n\n  offBeforeEach(listener) {\n    this.off('before', listener);\n    return this;\n  }\n\n  afterEach(listener, thisScope) {\n    this.on('after', listener, thisScope);\n    return this;\n  }\n\n  offAfterEach(listener) {\n    this.off('after', listener);\n    return this;\n  }\n}\n\nStorux.Store = Store;\n\n/**\n* Check if `value` is an instance of `Store`.\n*\n* @param  {*}  value Value to check.\n* @return {bool}\n*/\nStorux.isStore = isStore;\n\nStorux.removeScopePropsAfterCreation = [\n  '_createActionProxy',\n  '_generateActions',\n  'ensureActions',\n  'ensureSaveActions',\n  'mountAction',\n  'mountActions',\n];\n\nmodule.exports = {\n  Storux,\n  Store,\n  Scope,\n\n  /**\n   * Create an action.\n   *\n   * @decorator\n   * @param {string} name Action name to create.\n   * @return {function}\n   */\n  action(name) {\n    return function(target, key/* , desc */) {\n      target._mount[key] = {type: 'action', name, fn: target[key]};\n    };\n  },\n\n  /**\n   * Create a hook for `actionName`\n   *\n   * @decorator\n   * @param {string} actionName Action name to hook.\n   * @return {function}\n   */\n  hook(actionName) {\n    return function(target, key/* , desc */) {\n      target._mount[key] = {type: 'hook', key, actionName};\n    };\n  },\n};\n"]}